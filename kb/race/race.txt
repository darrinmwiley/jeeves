PROBLEM URL: https://open.kattis.com/problems/race
TAGS: dp, bitmasks, greedy
EXPLANATION:

The dp's aim is to find the minimal time to complete a certain set of tasks.

We represent the set of tasks completed as a bitmask ex.: if tasks 1, 3, and 7 were comleted the mask is 1000101 (lsb).

Because the time it takes to travel between 2 destinations is dependent on direction and the fact that traveling to destinations in a different order can save time, we also have to keep track of the last city visited in the dp state.

Thus, the dp state looks like:
    dp[set of tasks completed][last task completed from the set].

The recurrence is now:
    dp[mask][last_task] = for(all tasks in mask/set not equal to last_task) 
                              min(dp[mask][last_task], dp[mask ^ i][i] + time_to_travel[i][last_task] + time[last_task])
FOR ALL VALID last_tasks's (i.e make sure not to exceed T or deadline[last_task]).

There are special cases for when traveling fromthe start destination to other destinations and also traveling to the final destination.

Finding the lexicographically smallest sequence is easy: just loop for(mask <= 1 << 20) and print out the set represented by the 1st max whose total points is equal to the max total points seen/possible. 

