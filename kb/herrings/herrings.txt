PROBLEM URL: https://open.kattis.com/problems/herrings
TAGS: Dynamic programming
EXPLANATION: 
Let's think about a simplified version of this problem.
Let's assume L is 0, meaning every pool can have any
    number of herrings.
If we know the number of ways to divide each of, say, 
    N%10, 10 + N%10, and 20 + N%10 herrings into 3 pools, 
    we can proceed by finding the number of combinations 
    for N/10, N/10 - 1, N/10 - 2 and then multiplying the 
    results. Solving the problem of 20 + N%10 herrings is 
    finding out the number of ways to get the least 
    significant digit + a 20 carry term.  N/10 - 2 removes 
    the 20 carry term.
So, this inspires the solution of dp, where dp_i,j is 
    the number of combinations to get N%(10^i) + j*10^i.
    i represents the index on N and j represents the carry
    term.
This means dp_i,j = C(N[i]+10j-0)*dp_(i-1),0 + C(N[i]+10j-1)
    *dp_(i-1),1 + C(N[i]+20j-2)*dp_(i-1),2 where C(x) is the
    number of ways to add 3 one-digit non-3 numbers to get x.
Then, I want to find dp_(|N-1|),0

To include L, must include another dimension to the dp : k. 
    k is like a bitmask saying which pools have already
    surpassed the lower limit for sure. 
If each (i,j,k) takes a constant amount of time to compute,
    then the time is O(|N|) since there are only 3 possible
    carry terms and 2 possible comparison results for each 
    N index.
I use dp_0,j,k as a base case.
